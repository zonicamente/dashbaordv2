"use strict";
/**
 * @license
 * Copyright (c) 2022-2024 Open Text.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.serialize = void 0;
const buffer_writer_1 = require("./buffer-writer");
const fs_1 = require("fs");
const writer = new buffer_writer_1.Writer();
const PROTOCOL_MAJOR_FIXED = 3; // these have no bearing in new servers with protocol version >= 3.7
const PROTOCOL_MINOR_FIXED = 5; // these are required but unused
const startup = (opts) => {
    // protocol version
    writer.addInt16(PROTOCOL_MAJOR_FIXED).addInt16(PROTOCOL_MINOR_FIXED); // equivalent to adding Int32 (MAJOR << 16 | MINOR)
    for (const key of Object.keys(opts)) {
        if (key === 'protocol_version') { // the protocol_version is added as a 32 bit integer
            continue;
        }
        writer.addCString(key).addCString(opts[key]);
    }
    writer.addCString('protocol_version').addInt32(parseInt(opts['protocol_version'])).addCString('');
    var bodyBuffer = writer.addCString('').flush();
    // this message is sent without a code
    var length = bodyBuffer.length + 4; // server expects length of message to include the int32 telling the length
    return new buffer_writer_1.Writer().addInt32(length).add(bodyBuffer).flush();
};
const requestSsl = () => {
    const request = Buffer.allocUnsafe(8);
    request.writeInt32BE(8, 0);
    request.writeInt32BE(80877103, 4);
    return request;
};
const password = (password) => {
    return writer.addCString(password).flush(112 /* code.startup */);
};
const query = (text) => {
    return writer.addCString(text).flush(81 /* code.query */);
};
const emptyArray = [];
const parse = (query) => {
    // expect something like this:
    // { name: 'queryName',
    //   text: 'select * from blah',
    //   types: ['int8', 'bool'] }
    // normalize missing query names to allow for null
    const name = query.name || '';
    if (name.length > 63) {
        /* eslint-disable no-console */
        console.error('Warning! Postgres only supports 63 characters for query names.');
        console.error('You supplied %s (%s)', name, name.length);
        console.error('This can cause conflicts and silent errors executing queries');
        /* eslint-enable no-console */
    }
    const types = query.types || emptyArray;
    var len = types.length;
    var buffer = writer
        .addCString(name) // name of query
        .addCString(query.text) // actual query text
        .addInt16(len);
    for (var i = 0; i < len; i++) {
        buffer.addInt32(types[i]);
    }
    return writer.flush(80 /* code.parse */);
};
const paramWriter = new buffer_writer_1.Writer();
const writeValues = function (values, valueMapper) {
    for (let i = 0; i < values.length; i++) {
        const mappedVal = valueMapper ? valueMapper(values[i], i) : values[i];
        if (mappedVal == null) {
            // write -1 to the param writer to indicate null
            paramWriter.addInt32(-1);
        }
        else if (mappedVal instanceof Buffer) {
            // add the buffer to the param writer
            paramWriter.addInt32(mappedVal.length);
            paramWriter.add(mappedVal);
        }
        else {
            paramWriter.addInt32(Buffer.byteLength(mappedVal));
            paramWriter.addString(mappedVal);
        }
    }
};
const bind = (config = {}) => {
    // normalize config
    const portal = config.portal || '';
    const statement = config.statement || '';
    const binary = config.binary || false;
    const values = config.values || emptyArray;
    const parameterCount = values.length;
    const dataTypeIDs = config.dataTypeIDs || emptyArray;
    writer.addCString(portal).addCString(statement);
    // [VERTICA specific] The parameter format codes need to be added up front instead of being interleaved with the parameter values
    // parameter format codes.
    writer.addInt16(0); // tell the server that all parameter format codes from the driver will be default, text
    writer.addInt16(parameterCount); // number of parameters, must match number needed by query
    // [VERTICA specific] The type OIDs need to be added here
    // OIDs
    for (let i = 0; i < parameterCount; i++) {
        writer.addInt32(dataTypeIDs[i]);
    }
    writeValues(values, config.valueMapper);
    writer.add(paramWriter.flush());
    // result format codes
    // binary transfer not supported, will all be default, text all the time
    writer.addInt16(0);
    return writer.flush(66 /* code.bind */);
};
const emptyExecute = Buffer.from([69 /* code.execute */, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00]);
const execute = (config) => {
    // this is the happy path for most queries
    if (!config || (!config.portal && !config.rows)) {
        return emptyExecute;
    }
    const portal = config.portal || '';
    const rows = config.rows || 0;
    const portalLength = Buffer.byteLength(portal);
    const len = 4 + portalLength + 1 + 4;
    // one extra bit for code
    const buff = Buffer.allocUnsafe(1 + len);
    buff[0] = 69 /* code.execute */;
    buff.writeInt32BE(len, 1);
    buff.write(portal, 5, 'utf-8');
    buff[portalLength + 5] = 0; // null terminate portal cString
    buff.writeUInt32BE(rows, buff.length - 4);
    return buff;
};
const cancel = (processID, secretKey) => {
    const buffer = Buffer.allocUnsafe(16);
    buffer.writeInt32BE(16, 0);
    buffer.writeInt16BE(1234, 4);
    buffer.writeInt16BE(5678, 6);
    buffer.writeInt32BE(processID, 8);
    buffer.writeInt32BE(secretKey, 12);
    return buffer;
};
const cstringMessage = (code, string) => {
    const stringLen = Buffer.byteLength(string);
    const len = 4 + stringLen + 1;
    // one extra bit for code
    const buffer = Buffer.allocUnsafe(1 + len);
    buffer[0] = code;
    buffer.writeInt32BE(len, 1);
    buffer.write(string, 5, 'utf-8');
    buffer[len] = 0; // null terminate cString
    return buffer;
};
const emptyDescribePortal = writer.addCString('P').flush(68 /* code.describe */);
const emptyDescribeStatement = writer.addCString('S').flush(68 /* code.describe */);
const describe = (msg) => {
    return msg.name
        ? cstringMessage(68 /* code.describe */, `${msg.type}${msg.name || ''}`)
        : msg.type === 'P'
            ? emptyDescribePortal
            : emptyDescribeStatement;
};
const close = (msg) => {
    const text = `${msg.type}${msg.name || ''}`;
    return cstringMessage(67 /* code.close */, text);
};
const copyData = (chunk) => {
    return writer.add(chunk).flush(100 /* code.copyData */);
};
const copyError = (fileName, lineNumber, methodName, errorMsg) => {
    writer.addCString(fileName);
    writer.addInt32(lineNumber);
    writer.addCString(methodName);
    writer.addCString(errorMsg);
    return writer.flush(101 /* code.copyError */);
};
const copyFail = (message) => {
    return cstringMessage(102 /* code.copyFail */, message);
};
function getFileSize(filePath) {
    try {
        const stats = (0, fs_1.statSync)(filePath);
        return stats.size;
    }
    catch (error) {
        return -1; // or throw an exception if you prefer
    }
}
//numFiles: number, fileNames: string[], fileLengths: number[]
const verifiedFiles = (config) => {
    if (config.protocol_version < (3 << 16 | 15)) {
        writer.addInt16(config.numFiles);
    }
    else {
        writer.addInt32(config.numFiles);
    }
    for (let i = 0; i < config.numFiles; i++) {
        writer.addCString(config.fileNames[i]);
        writer.addInt32(0);
        writer.addInt32(getFileSize(config.fileNames[i]));
    }
    return writer.flush(70 /* code.verifiedFiles */);
};
const codeOnlyBuffer = (code) => Buffer.from([code, 0x00, 0x00, 0x00, 0x04]);
const flushBuffer = codeOnlyBuffer(72 /* code.flush */);
const syncBuffer = codeOnlyBuffer(83 /* code.sync */);
const endBuffer = codeOnlyBuffer(88 /* code.end */);
const copyDoneBuffer = codeOnlyBuffer(99 /* code.copyDone */);
const endOfBatchRequestBuffer = codeOnlyBuffer(106 /* code.endOfBatchRequest */);
const serialize = {
    startup,
    password,
    requestSsl,
    query,
    parse,
    bind,
    execute,
    describe,
    close,
    flush: () => flushBuffer,
    sync: () => syncBuffer,
    end: () => endBuffer,
    copyData,
    copyDone: () => copyDoneBuffer,
    copyError,
    copyFail,
    EndOfBatchRequest: () => endOfBatchRequestBuffer,
    cancel,
    verifiedFiles,
};
exports.serialize = serialize;
//# sourceMappingURL=serializer.js.map