"use strict";
/**
 * @license
 * Copyright (c) 2022-2024 Open Text.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Parser = void 0;
const backend_messages_1 = require("./backend-messages");
const buffer_reader_1 = require("./buffer-reader");
const assert_1 = __importDefault(require("assert"));
// every message is prefixed with a single bye
const CODE_LENGTH = 1;
// every message has an int32 length which includes itself but does
// NOT include the code in the length
const LEN_LENGTH = 4;
const HEADER_LENGTH = CODE_LENGTH + LEN_LENGTH;
const emptyBuffer = Buffer.allocUnsafe(0);
class Parser {
    constructor(opts) {
        this.buffer = emptyBuffer;
        this.bufferLength = 0;
        this.bufferOffset = 0;
        this.reader = new buffer_reader_1.BufferReader();
        if ((opts === null || opts === void 0 ? void 0 : opts.mode) === 'binary') {
            throw new Error('Binary mode not supported yet');
        }
        this.mode = (opts === null || opts === void 0 ? void 0 : opts.mode) || 'text';
    }
    parse(buffer, callback) {
        this.mergeBuffer(buffer);
        const bufferFullLength = this.bufferOffset + this.bufferLength;
        let offset = this.bufferOffset;
        while (offset + HEADER_LENGTH <= bufferFullLength) {
            // code is 1 byte long - it identifies the message type
            const code = this.buffer[offset];
            // length is 1 Uint32BE - it is the length of the message EXCLUDING the code
            const length = this.buffer.readUInt32BE(offset + CODE_LENGTH);
            const fullMessageLength = CODE_LENGTH + length;
            if (fullMessageLength + offset <= bufferFullLength) {
                const message = this.handlePacket(offset + HEADER_LENGTH, code, length, this.buffer);
                callback(message);
                offset += fullMessageLength;
            }
            else {
                break;
            }
        }
        if (offset === bufferFullLength) {
            // No more use for the buffer
            this.buffer = emptyBuffer;
            this.bufferLength = 0;
            this.bufferOffset = 0;
        }
        else {
            // Adjust the cursors of remainingBuffer
            this.bufferLength = bufferFullLength - offset;
            this.bufferOffset = offset;
        }
    }
    mergeBuffer(buffer) {
        if (this.bufferLength > 0) {
            const newLength = this.bufferLength + buffer.byteLength;
            const newFullLength = newLength + this.bufferOffset;
            if (newFullLength > this.buffer.byteLength) {
                // We can't concat the new buffer with the remaining one
                let newBuffer;
                if (newLength <= this.buffer.byteLength && this.bufferOffset >= this.bufferLength) {
                    // We can move the relevant part to the beginning of the buffer instead of allocating a new buffer
                    newBuffer = this.buffer;
                }
                else {
                    // Allocate a new larger buffer
                    let newBufferLength = this.buffer.byteLength * 2;
                    while (newLength >= newBufferLength) {
                        newBufferLength *= 2;
                    }
                    newBuffer = Buffer.allocUnsafe(newBufferLength);
                }
                // Move the remaining buffer to the new one
                this.buffer.copy(newBuffer, 0, this.bufferOffset, this.bufferOffset + this.bufferLength);
                this.buffer = newBuffer;
                this.bufferOffset = 0;
            }
            // Concat the new buffer with the remaining one
            buffer.copy(this.buffer, this.bufferOffset + this.bufferLength);
            this.bufferLength = newLength;
        }
        else {
            this.buffer = buffer;
            this.bufferOffset = 0;
            this.bufferLength = buffer.byteLength;
        }
    }
    handlePacket(offset, code, length, bytes) {
        switch (code) {
            case 50 /* MessageCodes.BindComplete */:
                return backend_messages_1.bindComplete;
            case 49 /* MessageCodes.ParseComplete */:
                return backend_messages_1.parseComplete;
            case 51 /* MessageCodes.CloseComplete */:
                return backend_messages_1.closeComplete;
            case 110 /* MessageCodes.NoData */:
                return backend_messages_1.noData;
            case 115 /* MessageCodes.PortalSuspended */:
                return backend_messages_1.portalSuspended;
            case 99 /* MessageCodes.CopyDoneResponse */:
                return backend_messages_1.copyDone;
            case 73 /* MessageCodes.EmptyQuery */:
                return backend_messages_1.emptyQuery;
            case 74 /* MessageCodes.EndOfBatchResponse */:
                return backend_messages_1.EndOfBatchResponse;
            case 68 /* MessageCodes.DataRow */:
                return this.parseDataRowMessage(offset, length, bytes);
            case 67 /* MessageCodes.CommandComplete */:
                return this.parseCommandCompleteMessage(offset, length, bytes);
            case 90 /* MessageCodes.ReadyForQuery */:
                return this.parseReadyForQueryMessage(offset, length, bytes);
            case 82 /* MessageCodes.AuthenticationResponse */:
                return this.parseAuthenticationResponse(offset, length, bytes);
            case 83 /* MessageCodes.ParameterStatus */:
                return this.parseParameterStatusMessage(offset, length, bytes);
            case 75 /* MessageCodes.BackendKeyData */:
                return this.parseBackendKeyData(offset, length, bytes);
            case 69 /* MessageCodes.ErrorMessage */:
                return this.parseErrorMessage(offset, length, bytes, 'error');
            case 78 /* MessageCodes.NoticeMessage */:
                return this.parseErrorMessage(offset, length, bytes, 'notice');
            case 84 /* MessageCodes.RowDescriptionMessage */:
                return this.parseRowDescriptionMessage(offset, length, bytes);
            case 116 /* MessageCodes.ParameterDescriptionMessage */:
                return this.parseParameterDescriptionMessage(offset, length, bytes);
            case 109 /* MessageCodes.CommandDescriptionMessage */:
                return this.parseCommandDescriptionMessage(offset, length, bytes);
            case 71 /* MessageCodes.CopyInResponse */:
                return this.parseCopyInResponseMessage(offset, length, bytes);
            case 72 /* MessageCodes.LoadFile */:
                return this.parseLoadFileMessage(offset, length, bytes);
            case 70 /* MessageCodes.VerifyFiles */:
                return this.parseVerifyFilesMessage(offset, length, bytes);
            case 79 /* MessageCodes.WriteFile */:
                return this.parseWriteFileMessage(offset, length, bytes);
            default:
                assert_1.default.fail(`unknown message code: ${code.toString(16)}`);
        }
    }
    parseReadyForQueryMessage(offset, length, bytes) {
        this.reader.setBuffer(offset, bytes);
        const status = this.reader.string(1);
        return new backend_messages_1.ReadyForQueryMessage(length, status);
    }
    parseCommandCompleteMessage(offset, length, bytes) {
        this.reader.setBuffer(offset, bytes);
        const text = this.reader.cstring();
        return new backend_messages_1.CommandCompleteMessage(length, text);
    }
    parseVerifyFilesMessage(offset, length, bytes) {
        this.reader.setBuffer(offset, bytes);
        const numFiles = this.reader.int16(); //int16 number of files, n
        let fileNames = null;
        if (numFiles !== 0) {
            fileNames = new Array(numFiles);
            for (let i = 0; i < numFiles; i++) {
                fileNames[i] = this.reader.cstring(); // string[n], name of each file
            }
        }
        const rejectFile = this.reader.cstring(); //string reject file name
        const exceptionFile = this.reader.cstring(); //string exceptions file name
        return new backend_messages_1.VerifyFilesMessage(length, numFiles, fileNames, rejectFile, exceptionFile);
    }
    parseWriteFileMessage(offset, length, bytes) {
        this.reader.setBuffer(offset, bytes);
        const fileName = this.reader.cstring();
        const fileLength = this.reader.int32();
        let fileContents;
        // if filename is empty, it means we used returnrejected instead of rejection file, the fileLength 
        // will be in mutliples of 8 bytes for each rejected row number in Little Endian 64 bit format
        if (fileName.length === 0) {
            fileContents = [];
            for (let i = 0; i < fileLength; i += 8) {
                fileContents.push(this.reader.int64LE());
            }
        }
        else {
            fileContents = this.reader.string(fileLength);
        }
        return new backend_messages_1.WriteFileMessage(length, fileName, fileLength, fileContents);
    }
    parseCopyInResponseMessage(offset, length, bytes) {
        this.reader.setBuffer(offset, bytes);
        const isBinary = this.reader.byte() !== 0;
        const columnCount = this.reader.int16();
        const message = new backend_messages_1.CopyInResponseMessage(length, isBinary, columnCount);
        for (let i = 0; i < columnCount; i++) {
            message.columnFormats[i] = this.reader.int16();
        }
        return message;
    }
    parseLoadFileMessage(offset, length, bytes) {
        this.reader.setBuffer(offset, bytes);
        const fileName = this.reader.cstring();
        return new backend_messages_1.LoadFileMessage(length, fileName);
    }
    parseRowDescriptionMessage(offset, length, bytes) {
        this.reader.setBuffer(offset, bytes);
        const fieldCount = this.reader.int16();
        const message = new backend_messages_1.RowDescriptionMessage(length, fieldCount);
        if (fieldCount === 0) {
            return message;
        }
        const nonNativeTypeCount = this.reader.int32();
        if (nonNativeTypeCount > 0) {
            throw new Error("Non native types are not yet supported");
        }
        for (let i = 0; i < fieldCount; i++) {
            message.fields[i] = this.parseField();
        }
        return message;
    }
    parseField() {
        const name = this.reader.cstring();
        const tableID = this.reader.uint64();
        var schemaName = "";
        var tableName = "";
        if (tableID) {
            schemaName = this.reader.cstring();
            tableName = this.reader.cstring();
        }
        const columnID = this.reader.int16();
        //const parentTypeID = this.reader.int16() // breadcrumb for complex types
        const isNonNative = this.reader.bytes(1);
        if (isNonNative[0] == 1) {
            throw new Error("Non native types are not yet supported");
        }
        const dataTypeID = this.reader.int32(); // for non native types this would be the index into the type mapping pool
        const dataTypeSize = this.reader.int16();
        const allowsNull = this.reader.int16();
        const isIdentity = this.reader.int16();
        const dataTypeModifier = this.reader.int32();
        const mode = this.reader.int16() === 0 ? 'text' : 'binary';
        return new backend_messages_1.Field(name, tableID, schemaName, tableName, columnID, dataTypeID, dataTypeSize, allowsNull, isIdentity, dataTypeModifier, mode);
    }
    parseParameterDescriptionMessage(offset, length, bytes) {
        this.reader.setBuffer(offset, bytes);
        const parameterCount = this.reader.int16();
        const message = new backend_messages_1.ParameterDescriptionMessage(length, parameterCount);
        if (parameterCount === 0) {
            return message;
        }
        const nonNativeTypeCount = this.reader.int32();
        if (nonNativeTypeCount > 0) {
            throw new Error("Non native types are not yet supported");
        }
        for (let i = 0; i < parameterCount; i++) {
            message.parameters[i] = this.parseParameter();
        }
        return message;
    }
    parseParameter() {
        const isNonNative = this.reader.byte() !== 0;
        if (isNonNative) { // should have been caught already, but just in case
            throw new Error("Non native types are not yet supported");
        }
        const oid = this.reader.int32();
        const typemod = this.reader.int32();
        const hasNotNull = this.reader.int16();
        return new backend_messages_1.Parameter(isNonNative, oid, typemod, hasNotNull);
    }
    parseCommandDescriptionMessage(offset, length, bytes) {
        this.reader.setBuffer(offset, bytes);
        const tag = this.reader.cstring();
        const convertedToCopy = this.reader.int16();
        const convertedStatement = this.reader.cstring();
        return new backend_messages_1.CommandDescriptionMessage(length, tag, convertedToCopy, convertedStatement);
    }
    parseDataRowMessage(offset, length, bytes) {
        this.reader.setBuffer(offset, bytes);
        const fieldCount = this.reader.int16();
        const fields = new Array(fieldCount);
        for (let i = 0; i < fieldCount; i++) {
            const len = this.reader.int32();
            // a -1 for length means the value of the field is null
            fields[i] = len === -1 ? null : this.reader.string(len);
        }
        return new backend_messages_1.DataRowMessage(length, fields);
    }
    parseParameterStatusMessage(offset, length, bytes) {
        this.reader.setBuffer(offset, bytes);
        const name = this.reader.cstring();
        const value = this.reader.cstring();
        return new backend_messages_1.ParameterStatusMessage(length, name, value);
    }
    parseBackendKeyData(offset, length, bytes) {
        this.reader.setBuffer(offset, bytes);
        const processID = this.reader.int32();
        const secretKey = this.reader.int32();
        return new backend_messages_1.BackendKeyDataMessage(length, processID, secretKey);
    }
    parseAuthenticationResponse(offset, length, bytes) {
        this.reader.setBuffer(offset, bytes);
        const code = this.reader.int32();
        // TODO(bmc): maybe better types here
        const message = {
            name: 'authenticationOk',
            length,
        };
        switch (code) {
            case 0: // AuthenticationOk
                break;
            case 3: // AuthenticationCleartextPassword
                if (message.length === 8) {
                    message.name = 'authenticationCleartextPassword';
                }
                break;
            case 5: // AuthenticationMD5Password
                if (message.length === 32) {
                    message.name = 'authenticationMD5Password';
                    const salt = this.reader.bytes(4);
                    return new backend_messages_1.AuthenticationMD5Password(length, salt);
                }
                break;
            case 12: // AuthenticationOAuthPassword
                message.name = 'authenticationOAuthPassword';
                break;
            case 65536: // AuthenticationHashPassword
            case 66048: // AuthenticationHashSHA512Password
                if (message.length === 32) {
                    const salt = this.reader.bytes(4);
                    const userSaltLen = this.reader.int32();
                    const userSalt = this.reader.bytes(16);
                    return new backend_messages_1.AuthenticationSHA512Password(length, salt, userSalt);
                }
                break;
            case 9: // PasswordExpired
                return new backend_messages_1.DatabaseError('Could not authenticate: Password expired.', 0, 'error');
            default:
                throw new Error('Unknown authentication request message type ' + code);
        }
        return message;
    }
    parseErrorMessage(offset, length, bytes, name) {
        this.reader.setBuffer(offset, bytes);
        const fields = {};
        let fieldType = this.reader.string(1);
        while (fieldType !== '\0') {
            fields[fieldType] = this.reader.cstring();
            fieldType = this.reader.string(1);
        }
        const messageValue = fields.M;
        const message = name === 'notice' ? new backend_messages_1.NoticeMessage(length, messageValue) : new backend_messages_1.DatabaseError(messageValue, length, name);
        message.severity = fields.S;
        message.code = fields.C;
        message.detail = fields.D;
        message.hint = fields.H;
        message.position = fields.P;
        message.internalPosition = fields.p;
        message.internalQuery = fields.q;
        message.where = fields.W;
        message.schema = fields.s;
        message.table = fields.t;
        message.column = fields.c;
        message.dataType = fields.d;
        message.constraint = fields.n;
        message.file = fields.F;
        message.line = fields.L;
        message.routine = fields.R;
        return message;
    }
}
exports.Parser = Parser;
//# sourceMappingURL=parser.js.map